"use strict";
var PersistenceAnnotation_1 = require("../annotations/PersistenceAnnotation");
var Serializer_1 = require("../serializer/Serializer");
var SerializationPath_1 = require("./SerializationPath");
var Collection_1 = require("./Collection");
var MeteorObjectRetriever = (function () {
    function MeteorObjectRetriever() {
    }
    MeteorObjectRetriever.prototype.getId = function (object) {
        if (object._serializationPath)
            return object._serializationPath.toString();
        else {
            var objectClass = PersistenceAnnotation_1.PersistenceAnnotation.getClass(object);
            var idPropertyName = PersistenceAnnotation_1.PersistenceAnnotation.getIdPropertyName(objectClass);
            var id = object[idPropertyName];
            if (PersistenceAnnotation_1.PersistenceAnnotation.isRootEntity(objectClass) && id) {
                return new SerializationPath_1.default(this, PersistenceAnnotation_1.PersistenceAnnotation.getCollectionName(objectClass), id).toString();
            }
            else {
                throw new Error("Error while 'toString'. Objects that should be stored as foreign keys need to be persisted beforehand or be the root entity of a collection and have an id.");
            }
        }
    };
    MeteorObjectRetriever.prototype.getObject = function (s) {
        if (typeof s != "string")
            throw new Error("Path needs to be a string");
        var sPath = new SerializationPath_1.default(this, s);
        var collectionName = sPath.getCollectionName();
        var collection = collectionName ? Collection_1.default.getByName(collectionName) : undefined;
        if (collection) {
            var rootValue = collection.getById(sPath.getId());
            var newValue = rootValue ? sPath.getSubObject(rootValue) : undefined;
            return newValue;
        }
        else
            throw new Error("No collection found to retrieve object. Key:" + s);
    };
    MeteorObjectRetriever.prototype.preToDocument = function (o) {
        // noop
    };
    MeteorObjectRetriever.prototype.postToObject = function (o) {
        this.updateSerializationPaths(o);
        this.retrieveLocalKeys(o);
    };
    MeteorObjectRetriever.prototype.setSerializationPath = function (o, pPath) {
        PersistenceAnnotation_1.setNonEnumerableProperty(o, "_serializationPath", pPath);
        PersistenceAnnotation_1.setNonEnumerableProperty(o, "_objectRetriever", this);
    };
    // if I could I would make this package protected
    MeteorObjectRetriever.prototype.updateSerializationPaths = function (object, visited) {
        var that = this;
        if (!visited)
            visited = [];
        if (visited.indexOf(object) != -1)
            return;
        if (!object || typeof object != "object")
            return;
        visited.push(object);
        var objectClass = PersistenceAnnotation_1.PersistenceAnnotation.getClass(object);
        if (PersistenceAnnotation_1.PersistenceAnnotation.isRootEntity(objectClass)) {
            if (!object._serializationPath) {
                var idPropertyName = PersistenceAnnotation_1.PersistenceAnnotation.getIdPropertyName(objectClass);
                var id = object[idPropertyName];
                if (id)
                    this.setSerializationPath(object, new SerializationPath_1.default(this, PersistenceAnnotation_1.PersistenceAnnotation.getCollectionName(objectClass), id));
            }
        }
        if (!object._serializationPath)
            return; // we're done here
        PersistenceAnnotation_1.PersistenceAnnotation.getTypedPropertyNames(objectClass).forEach(function (typedPropertyName) {
            if (!PersistenceAnnotation_1.PersistenceAnnotation.isStoredAsForeignKeys(objectClass, typedPropertyName)) {
                //console.log("updating foreignkey property " + typedPropertyName);
                var v = object[typedPropertyName];
                if (v) {
                    if (PersistenceAnnotation_1.PersistenceAnnotation.isArrayOrMap(objectClass, typedPropertyName)) {
                        //console.log("updating foreignkey property " + typedPropertyName + " is array");
                        for (var i in v) {
                            var e = v[i];
                            if (e) {
                                var index = i;
                                if (PersistenceAnnotation_1.getId(e))
                                    index = PersistenceAnnotation_1.getId(e);
                                //console.log("updating persistnece path for isArrayOrMap " + typedPropertyName + "  key:" + i + " value:", e, "object: ", object);
                                that.setSerializationPath(e, object._serializationPath.clone());
                                e._serializationPath.appendArrayOrMapLookup(typedPropertyName, index);
                                that.updateSerializationPaths(e, visited);
                            }
                        }
                    }
                    else {
                        //console.log("updating foreignkey property direct property " + typedPropertyName);
                        that.setSerializationPath(v, object._serializationPath.clone());
                        v._serializationPath.appendPropertyLookup(typedPropertyName);
                        that.updateSerializationPaths(v, visited);
                    }
                }
            }
            else {
                //console.log( "foreign key "+typedPropertyName );
                if (!Serializer_1.default.needsLazyLoading(object, typedPropertyName)) {
                    var v = object[typedPropertyName];
                    if (v) {
                        if (PersistenceAnnotation_1.PersistenceAnnotation.isArrayOrMap(objectClass, typedPropertyName)) {
                            for (var i in v) {
                                var e = v[i];
                                if (e && !e._serializationPath) {
                                    //console.log("non- foreign key array/map entry key:"+i+" value:"+e);
                                    that.updateSerializationPaths(e, visited);
                                }
                            }
                        }
                        else if (!v._serializationPath)
                            that.updateSerializationPaths(v, visited);
                    }
                }
            }
        });
    };
    MeteorObjectRetriever.prototype.retrieveLocalKeys = function (o, visited, rootObject) {
        if (!o)
            return;
        if (!visited)
            visited = [];
        if (visited.indexOf(o) != -1)
            return;
        visited.push(o);
        var that = this;
        if (!rootObject)
            rootObject = o;
        var theClass = PersistenceAnnotation_1.PersistenceAnnotation.getClass(o);
        //console.log("Retrieving local keys for ",o," class: ", theClass);
        var spp = rootObject._serializationPath;
        if (spp) {
            var that = this;
            PersistenceAnnotation_1.PersistenceAnnotation.getTypedPropertyNames(theClass).forEach(function (properyName) {
                //console.log("Retrieviing local keys for property "+properyName);
                var isKeys = PersistenceAnnotation_1.PersistenceAnnotation.isStoredAsForeignKeys(theClass, properyName);
                var needsLazyLoading = Serializer_1.default.needsLazyLoading(o, properyName);
                var isArray = PersistenceAnnotation_1.PersistenceAnnotation.isArrayOrMap(theClass, properyName);
                if (isKeys && needsLazyLoading && !isArray) {
                    var key = o["_" + properyName];
                    // this is where it is determined if an object is local
                    var pp = new SerializationPath_1.default(this, key);
                    if (pp.getCollectionName() == spp.getCollectionName() && pp.getId() == spp.getId()) {
                        //console.log("found a local key :"+properyName);
                        o[properyName] = pp.getSubObject(rootObject);
                    }
                }
                // TODO support arrays
                if (!Serializer_1.default.needsLazyLoading(o, properyName)) {
                    if (isArray) {
                        for (var i in o[properyName]) {
                            that.retrieveLocalKeys(o[properyName][i], visited, rootObject);
                        }
                    }
                    else
                        that.retrieveLocalKeys(o[properyName], visited, rootObject);
                }
            });
        }
    };
    return MeteorObjectRetriever;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MeteorObjectRetriever;
//# sourceMappingURL=MeteorObjectRetriever.js.map