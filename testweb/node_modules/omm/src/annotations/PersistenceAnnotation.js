"use strict";
var EventContext = (function () {
    function EventContext(o, coll /*omm.Collection<T>*/) {
        this.cancelledError = false;
        this.object = o;
        if (o)
            this.objectId = getId(o);
        this.collection = coll;
    }
    EventContext.prototype.cancel = function (err) {
        this.cancelledError = err;
    };
    EventContext.prototype.cancelledWithError = function () {
        return this.cancelledError;
    };
    return EventContext;
}());
exports.EventContext = EventContext;
function setNonEnumerableProperty(obj, propertyName, value) {
    if (!Object.getOwnPropertyDescriptor(obj, propertyName)) {
        Object.defineProperty(obj, propertyName, {
            configurable: false,
            enumerable: false,
            writable: true
        });
    }
    obj[propertyName] = value;
}
exports.setNonEnumerableProperty = setNonEnumerableProperty;
// it seems that the local variable that "reflect" uses is prone to the same difficulties when it gets loaded
// multiple times. This is why it's been removed until it is supported by the Runtime directly.
function defineMetadata(propertyName, value, cls) {
    if (!cls.hasOwnProperty("_ommAnnotations")) {
        setNonEnumerableProperty(cls, "_ommAnnotations", {});
    }
    var _ommAnnotations = cls._ommAnnotations;
    _ommAnnotations[propertyName] = value;
}
exports.defineMetadata = defineMetadata;
function getMetadata(propertyName, cls) {
    if (cls.hasOwnProperty("_ommAnnotations"))
        return cls["_ommAnnotations"][propertyName];
    else {
        return undefined;
    }
}
exports.getMetadata = getMetadata;
function Entity(entityNameOrP1) {
    var entityName;
    if (typeof entityNameOrP1 == "string") {
        entityName = entityNameOrP1;
    }
    else {
        var n = entityNameOrP1.toString();
        n = n.substr('function '.length);
        n = n.substr(0, n.indexOf('('));
        entityName = n;
    }
    var f = function (p1) {
        var typeClass = p1;
        defineMetadata("persistence:entity", true, typeClass);
        exports.entityClasses[entityName] = typeClass;
        Object.defineProperty(p1, "_ommClassName", {
            value: entityName,
            writable: false,
            configurable: false,
            enumerable: false
        });
    };
    if (typeof entityNameOrP1 == "string") {
        return f;
    }
    else {
        f(entityNameOrP1);
    }
}
exports.Entity = Entity;
/**
 * Declares a class as an entity.
 * @param c {function} The constructor function of the entity class.
 * @memberof omm
 */
function addEntity(c) {
    Entity(c);
}
exports.addEntity = addEntity;
function getDefaultCollectionName(t) {
    return className(t);
}
exports.getDefaultCollectionName = getDefaultCollectionName;
function addCollectionRoot(t, collectionName) {
    defineMetadata("persistence:collectionName", collectionName, t);
}
exports.addCollectionRoot = addCollectionRoot;
function Wrap(t, functionName, objectDescriptor) {
    //CollectionUpdate(t,functionName,objectDescriptor);
    //MeteorMethod(t,functionName,objectDescriptor);
    //defineMetadata("persistence:wrap", true, (<any>t)[functionName] );
    CollectionUpdate(t, functionName);
    MeteorMethod({ replaceWithCall: true })(t, functionName, objectDescriptor);
}
exports.Wrap = Wrap;
// js api
function wrap(t, functionName) {
    collectionUpdate(t, functionName);
    MeteorMethod({ replaceWithCall: true })(t, functionName, undefined);
}
exports.wrap = wrap;
function CollectionUpdate(p1, fName) {
    var options = {};
    if (fName) {
        PersistenceAnnotation.setPropertyProperty(p1, fName, "collectionUpdate", options);
    }
    else {
        return function (t, functionName, objectDescriptor) {
            options = p1;
            PersistenceAnnotation.setPropertyProperty(t, functionName, "collectionUpdate", options);
        };
    }
}
exports.CollectionUpdate = CollectionUpdate;
/**
 * Used to declare a function of a class as a "collection update". That means that whenever the function is called
 * the same operation is also invoked on the document in the collection.
 * @param c {function} The constructor function of the entity class.
 * @param functionName {string} The name of the function that is declared as a "collection update".
 * @param options
 * @memberof omm
 */
function collectionUpdate(c, functionName, options) {
    if (!options) {
        CollectionUpdate(c, functionName);
    }
    else {
        CollectionUpdate(options)(c, functionName);
    }
}
exports.collectionUpdate = collectionUpdate;
function ArrayOrMap(typeClassName) {
    return function (targetPrototypeObject, propertyName) {
        //console.log("  "+propertyName+" as collection of "+typeClassName);
        PersistenceAnnotation.setPropertyProperty(targetPrototypeObject.constructor, propertyName, "type", typeClassName);
        PersistenceAnnotation.setPropertyProperty(targetPrototypeObject.constructor, propertyName, "arrayOrMap", true);
    };
}
exports.ArrayOrMap = ArrayOrMap;
function ArrayType(typeClassName) {
    return ArrayOrMap(typeClassName);
}
exports.ArrayType = ArrayType;
/**
 * Declares the type of the values in the array. This is synonymous to {@link dictionaryType}.
 * @param c {function} The constructor function of the entity class.
 * @param propertyName {string} The name of the array property.
 * @param typeClassName {string} The classname of the entity that the array contains.
 * @memberof omm
 */
function arrayType(c, propertyName, typeClassName) {
    ArrayOrMap(typeClassName)(c.prototype, propertyName);
}
exports.arrayType = arrayType;
function DictionaryType(typeClassName) {
    return ArrayOrMap(typeClassName);
}
exports.DictionaryType = DictionaryType;
/**
 * Declares the type of the values in the dictionary. This is synonymous to {@link arrayType}.
 * @param c {function} The constructor function of the entity class.
 * @param propertyName {string} The name of the array property.
 * @param typeClassName {string} The classname of the entity that the array contains.
 * @memberof omm
 */
function dictionaryType(typeClassName) {
    return ArrayOrMap(typeClassName);
}
exports.dictionaryType = dictionaryType;
function AsForeignKeys(targetPrototypeObject, propertyName) {
    return PersistenceAnnotation.setPropertyProperty(targetPrototypeObject.constructor, propertyName, "askeys", true);
}
exports.AsForeignKeys = AsForeignKeys;
function Id(targetPrototypeObject, propertyName) {
    DocumentName("_id")(targetPrototypeObject, propertyName);
}
exports.Id = Id;
function Parent(targetPrototypeObject, propertyName) {
    PersistenceAnnotation.setPropertyProperty(targetPrototypeObject.constructor, propertyName, "parent", 1);
}
exports.Parent = Parent;
/**
 * Used to declare which property is used as the value for "_id".
 * @param c {function} The constructor function of the entity class.
 * @param propertyName {string} The name of the id property.
 * @memberof omm
 */
function idProperty(c, propertyName) {
    Id(c.prototype, propertyName);
}
exports.idProperty = idProperty;
function Ignore(targetPrototypeObject, propertyName) {
    PersistenceAnnotation.setPropertyProperty(targetPrototypeObject.constructor, propertyName, "ignore", true);
}
exports.Ignore = Ignore;
/**
 * Declares that a property of an entity is not persisted.
 * @param c {function} The constructor function of the entity class.
 * @param propertyName {string} The name of the id property.
 * @memberof omm
 */
function ignoreProperty(c, propertyName) {
    Ignore(c.prototype, propertyName);
}
exports.ignoreProperty = ignoreProperty;
function DocumentName(name) {
    return function (targetPrototypeObject, propertyName) {
        var objNames = getMetadata("objectNames", targetPrototypeObject);
        if (!objNames) {
            objNames = {};
            defineMetadata("objectNames", objNames, targetPrototypeObject);
        }
        var documentNames = getMetadata("documentNames", targetPrototypeObject);
        if (!documentNames) {
            documentNames = {};
            defineMetadata("documentNames", documentNames, targetPrototypeObject);
        }
        objNames[name] = propertyName;
        documentNames[propertyName] = name;
    };
}
exports.DocumentName = DocumentName;
// for grammar reasons
function AsForeignKey(targetPrototypeObject, propertyName) {
    return AsForeignKeys(targetPrototypeObject, propertyName);
}
exports.AsForeignKey = AsForeignKey;
function Type(typeClassName) {
    return function (targetPrototypeObject, propertyName) {
        //console.log("  "+propertyName+" as "+typeClassName);
        PersistenceAnnotation.setPropertyProperty(targetPrototypeObject.constructor, propertyName, "type", typeClassName);
    };
}
exports.Type = Type;
function type(t, propertyName, className) {
    Type(className)(t.prototype, propertyName);
}
exports.type = type;
// plain js api
function propertyType(t, propertyName, typeClassName) {
    Type(typeClassName)(t.prototype, propertyName);
}
exports.propertyType = propertyType;
function propertyArrayType(t, propertyName, typeClassName) {
    ArrayType(typeClassName)(t.prototype, propertyName);
}
exports.propertyArrayType = propertyArrayType;
function propertyDictionaryType(t, propertyName, typeClassName) {
    DictionaryType(typeClassName)(t.prototype, propertyName);
}
exports.propertyDictionaryType = propertyDictionaryType;
/**
 * Declares that a property that stores an Entity is to be stored as a string which references the entity rather than
 * the whole entity. Use this to break up circular references.
 *
 * @param c {function} The constructor function of the class.
 * @param propertyName {string} The name of the property that should be stored as a string.
 * @memberof omm
 */
function asForeignKey(c, propertyName) {
    AsForeignKey(c.prototype, propertyName);
}
exports.asForeignKey = asForeignKey;
/**
 * Returns the property previously defined with {@link idProperty} or the _id property.
 * @param o {Object} the object
 * @returns {any}
 * @memberof omm
 */
function getId(o) {
    var idPropertyName = PersistenceAnnotation.getIdPropertyName(PersistenceAnnotation.getClass(o));
    if (!idPropertyName)
        throw new Error("No id property defined for object of class " + PersistenceAnnotation.getClass(o));
    else
        return o[idPropertyName];
}
exports.getId = getId;
function className(fun) {
    return typeof fun == "function" ? fun['_ommClassName'] : undefined;
}
exports.className = className;
function MeteorMethod(p1, p2) {
    if (typeof p1 == "object" && typeof p2 == "string") {
        var options = { isStatic: false };
        options.parentObject = p1;
        options.functionName = p2;
        options.name = p2;
        exports.meteorMethodFunctions.push(options);
    }
    else {
        return function (t, functionName, objectDescriptor) {
            var options = {};
            if (typeof p1 == "object")
                options = p1;
            else if (typeof p1 == "string") {
                if (typeof p2 == "object")
                    options = p2;
                options.name = p1;
            }
            options.functionName = functionName;
            options.isStatic = false;
            options.parentObject = t;
            if (!options.name) {
                options.name = functionName;
            }
            exports.meteorMethodFunctions.push(options);
        };
    }
}
exports.MeteorMethod = MeteorMethod;
function StaticMeteorMethod(p1, p2) {
    if (typeof p1 == "function" && typeof p2 == "string") {
        var options = { isStatic: true };
        options.parentObject = p1;
        options.functionName = p2;
        options.object = p1;
        if (!options.name)
            options.name = p2;
        exports.meteorMethodFunctions.push(options);
    }
    else {
        return function (t, functionName, objectDescriptor) {
            var options = {};
            if (typeof p1 == "object")
                options = p1;
            else if (typeof p1 == "string") {
                if (typeof p2 == "object")
                    options = p2;
                options.name = p1;
            }
            options.parentObject = t;
            options.functionName = functionName;
            options.isStatic = true;
            options.object = t;
            if (!options.name)
                options.name = functionName;
            exports.meteorMethodFunctions.push(options);
        };
    }
}
exports.StaticMeteorMethod = StaticMeteorMethod;
var PersistenceAnnotation = (function () {
    function PersistenceAnnotation() {
    }
    PersistenceAnnotation.getMethodOptions = function (functionName) {
        for (var i = 0; i < exports.meteorMethodFunctions.length; i++) {
            if (exports.meteorMethodFunctions[i].name == functionName)
                return exports.meteorMethodFunctions[i];
        }
        return undefined;
    };
    PersistenceAnnotation.getMethodFunctionNames = function (c) {
        var ret = [];
        for (var i = 0; i < exports.meteorMethodFunctions.length; i++) {
            var methodOptions = exports.meteorMethodFunctions[i];
            if (methodOptions.parentObject == c)
                ret.push(methodOptions.name);
        }
        return ret;
    };
    PersistenceAnnotation.getMethodFunctionNamesByObject = function (o) {
        var ret = [];
        for (var i = 0; i < exports.meteorMethodFunctions.length; i++) {
            var methodOptions = exports.meteorMethodFunctions[i];
            if (methodOptions.object == o)
                ret.push(exports.meteorMethodFunctions[i].name);
        }
        return ret;
    };
    PersistenceAnnotation.getAllMethodFunctionNames = function () {
        var ret = [];
        for (var i = 0; i < exports.meteorMethodFunctions.length; i++) {
            ret.push(exports.meteorMethodFunctions[i].name);
        }
        return ret;
    };
    PersistenceAnnotation.getClass = function (o) {
        if (o)
            return o.constructor;
        else
            return undefined;
    };
    // ---- Entity ----
    PersistenceAnnotation.getEntityClassByName = function (className) {
        return exports.entityClasses[className];
    };
    PersistenceAnnotation.getCollectionClasses = function () {
        var result = [];
        for (var i in exports.entityClasses) {
            var entityClass = exports.entityClasses[i];
            if (PersistenceAnnotation.getCollectionName(entityClass))
                result.push(entityClass);
        }
        return result;
    };
    PersistenceAnnotation.getEntityClasses = function () {
        var result = [];
        for (var i in exports.entityClasses) {
            var entityClass = exports.entityClasses[i];
            result.push(entityClass);
        }
        return result;
    };
    PersistenceAnnotation.getCollectionName = function (f) {
        return getMetadata("persistence:collectionName", f);
    };
    PersistenceAnnotation.isRootEntity = function (f) {
        return !!PersistenceAnnotation.getCollectionName(f);
    };
    PersistenceAnnotation.isEntity = function (f) {
        return !!exports.entityClasses[className(f)];
    };
    PersistenceAnnotation.getDocumentPropertyName = function (typeClass, objectPropertyName) {
        var documentNames = getMetadata("documentNames", typeClass.prototype);
        return documentNames ? documentNames[objectPropertyName] : undefined;
    };
    PersistenceAnnotation.getObjectPropertyName = function (typeClass, documentPropertyName) {
        var objectNames = getMetadata("objectNames", typeClass.prototype);
        return objectNames ? objectNames[documentPropertyName] : undefined;
    };
    PersistenceAnnotation.isArrayOrMap = function (f, propertyName) {
        while (f != Object) {
            if (PersistenceAnnotation.getPropertyProperty(f, propertyName, "arrayOrMap"))
                return true;
            f = PersistenceAnnotation.getParentClass(f);
        }
        return false;
    };
    // ---- typed properties ----
    PersistenceAnnotation.getPropertyClass = function (f, propertyName) {
        while (f != Object) {
            var className = PersistenceAnnotation.getPropertyProperty(f, propertyName, "type");
            if (className)
                return PersistenceAnnotation.getEntityClassByName(className);
            f = PersistenceAnnotation.getParentClass(f);
        }
        return undefined;
    };
    PersistenceAnnotation.getTypedPropertyNames = function (f) {
        var result = [];
        while (f != Object) {
            var props = getMetadata("persistence:typedproperties", f);
            for (var i in props) {
                if (PersistenceAnnotation.getPropertyClass(f, i))
                    result.push(i);
            }
            f = PersistenceAnnotation.getParentClass(f);
        }
        return result;
    };
    PersistenceAnnotation.setPropertyProperty = function (cls, propertyName, property, value) {
        var arr = getMetadata("persistence:typedproperties", cls);
        if (!arr) {
            arr = {};
            defineMetadata("persistence:typedproperties", arr, cls);
        }
        var propProps = arr[propertyName];
        if (!propProps) {
            propProps = {};
            arr[propertyName] = propProps;
        }
        propProps[property] = value;
    };
    PersistenceAnnotation.getPropertyProperty = function (cls, propertyName, propertyProperty) {
        var arr = getMetadata("persistence:typedproperties", cls);
        if (arr && arr[propertyName]) {
            return arr[propertyName][propertyProperty];
        }
        return undefined;
    };
    PersistenceAnnotation.getParentClass = function (t) {
        return Object.getPrototypeOf(t.prototype).constructor;
    };
    PersistenceAnnotation.getIdPropertyName = function (t) {
        return PersistenceAnnotation.getObjectPropertyName(t, "_id") || "_id";
    };
    // ---- AsForeignKeys ----
    PersistenceAnnotation.isStoredAsForeignKeys = function (f, propertyName) {
        while (f != Object) {
            if (PersistenceAnnotation.getPropertyProperty(f, propertyName, "askeys"))
                return true;
            f = PersistenceAnnotation.getParentClass(f);
        }
        return false;
    };
    PersistenceAnnotation.isIgnored = function (f, propertyName) {
        //return PersistenceAnnotation.getPropertyProperty(typeClass, propertyName, "ignore");
        while (f != Object) {
            if (PersistenceAnnotation.getPropertyProperty(f, propertyName, "ignore"))
                return true;
            f = PersistenceAnnotation.getParentClass(f);
        }
        return false;
    };
    PersistenceAnnotation.isParent = function (f, propertyName) {
        //return PersistenceAnnotation.getPropertyProperty(typeClass, propertyName, "ignore");
        while (f != Object) {
            if (PersistenceAnnotation.getPropertyProperty(f, propertyName, "parent"))
                return true;
            f = PersistenceAnnotation.getParentClass(f);
        }
        return false;
    };
    PersistenceAnnotation.getParentPropertyNames = function (f) {
        var result = [];
        while (f != Object) {
            var props = getMetadata("persistence:typedproperties", f);
            for (var i in props) {
                if (PersistenceAnnotation.isParent(f, i))
                    result.push(i);
            }
            f = PersistenceAnnotation.getParentClass(f);
        }
        return result;
    };
    // ---- Wrap ----
    PersistenceAnnotation.getWrappedFunctionNames = function (f) {
        return PersistenceAnnotation.getPropertyNamesByMetaData(f.prototype, "persistence:wrap");
    };
    PersistenceAnnotation.getCollectionUpdateOptions = function (cls, functionName) {
        return PersistenceAnnotation.getPropertyProperty(cls.prototype, functionName, "collectionUpdate");
    };
    PersistenceAnnotation.getCollectionUpdateFunctionNames = function (f) {
        var result = [];
        var props = getMetadata("persistence:typedproperties", f.prototype);
        for (var i in props) {
            if (PersistenceAnnotation.getCollectionUpdateOptions(f, i))
                result.push(i);
        }
        return result;
    };
    PersistenceAnnotation.getPropertyNamesByMetaData = function (o, metaData) {
        var result = [];
        for (var i in o) {
            var value = o[i];
            //console.log("Cave man style debugging 1",i, value,getMetadata("persistence:wrap", value) );
            if (typeof value == "function" && getMetadata(metaData, value))
                result.push(i);
        }
        return result;
    };
    return PersistenceAnnotation;
}());
exports.PersistenceAnnotation = PersistenceAnnotation;
(function () {
    var data;
    if (typeof global != "undefined") {
        if (!global["_omm_data"])
            global["_omm_data"] = {};
        data = global["_omm_data"];
    }
    else if (typeof window != "undefined") {
        if (!window["_omm_data"])
            window["_omm_data"] = {};
        data = window["_omm_data"];
    }
    else
        data = {};
    if (!data.entityClasses)
        data.entityClasses = {};
    exports.entityClasses = data.entityClasses;
    if (!data.environmentReferences)
        data.environmentReferences = {};
    exports.environmentReferences = data.environmentReferences;
    if (!data.registeredObjects)
        data.registeredObjects = {};
    exports.registeredObjects = data.registeredObjects;
    if (!data.meteorMethodFunctions)
        data.meteorMethodFunctions = [];
    exports.meteorMethodFunctions = data.meteorMethodFunctions;
    if (!data.eventListeners)
        data.eventListeners = {};
    exports.eventListeners = data.eventListeners;
})();
//# sourceMappingURL=PersistenceAnnotation.js.map