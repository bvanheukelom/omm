/**
 * Created by bert on 23.03.16.
 */
/// <reference path="../typings/underscore/underscore.d.ts"/>
"use strict";
var _ = require("underscore");
var omm = require("../src/omm");
var MockCollection = (function () {
    function MockCollection(name) {
        this.nextId = 0;
        this.name = name;
    }
    MockCollection.prototype._ensureIndex = function () {
    };
    MockCollection.prototype.getData = function () {
        if (!MockCollection.data[this.name]) {
            MockCollection.data[this.name] = {};
        }
        return MockCollection.data[this.name];
    };
    MockCollection.prototype.getAllData = function () {
        return MockCollection.data;
    };
    MockCollection.prototype.deepClone = function (o) {
        var n = _.clone(o);
        for (var i in n) {
            if (typeof n[i] == "object") {
                n[i] = this.deepClone(o[i]);
            }
        }
        return n;
    };
    MockCollection.prototype.find = function (pattern) {
        if (this.finder) {
            var r = this.finder(pattern, this.getData());
            if (r)
                return new MockCursor(this.deepClone(r));
        }
        if (pattern._id) {
            return new MockCursor(this.deepClone([this.getData()[pattern._id]]));
        }
        else
            return new MockCursor(this.deepClone(_.values(this.getData())));
    };
    MockCollection.prototype.update = function (pattern, data) {
        if (pattern._id) {
            this.getData()[pattern._id] = data;
            return 1;
        }
        else {
            throw new Error("Not implemented: Cant update without an _id");
        }
    };
    MockCollection.prototype.findOne = function (pattern) {
        if (pattern._id)
            return this.getData()[pattern._id];
        else {
            var v = _.values(this.getData());
            if (v.length > 0) {
                return v[0];
            }
        }
        return undefined;
    };
    MockCollection.prototype.nextID = function () {
        this.nextId++;
        return this.nextId + "";
    };
    MockCollection.prototype.insert = function (i, cb) {
        if (!i._id)
            i._id = this.nextID();
        this.getData()[i._id] = i;
        if (cb)
            cb(undefined, i._id);
        return i._id;
    };
    MockCollection.prototype.remove = function (id, cb) {
        delete this.getData()[id];
        if (cb)
            cb();
    };
    MockCollection.data = {};
    return MockCollection;
}());
exports.MockCollection = MockCollection;
var MockCursor = (function () {
    function MockCursor(data) {
        this.data = data;
    }
    MockCursor.prototype.fetch = function () {
        return this.data;
    };
    return MockCursor;
}());
exports.MockCursor = MockCursor;
var MockObjectId = (function () {
    function MockObjectId(hex) {
        this._str = "" + MockObjectId.nextId++;
    }
    MockObjectId.nextId = 0;
    return MockObjectId;
}());
exports.MockObjectId = MockObjectId;
var MockMongo = (function () {
    function MockMongo() {
        this.ObjectID = MockObjectId;
        this.Collection = MockCollection;
    }
    return MockMongo;
}());
exports.MockMongo = MockMongo;
var MockError = (function () {
    function MockError(error, reason, details) {
        this.error = error;
        this.details = details;
        this.reason = reason;
    }
    return MockError;
}());
exports.MockError = MockError;
var MockMeteor = (function () {
    function MockMeteor() {
        this.theMethods = {};
        this.Error = MockError;
        this.users = new MockCollection('users');
        this.startupFkts = [];
        this.isServer = true;
        this.isClient = false;
        this.call = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var f = this.theMethods[name];
            var callback;
            if (args.length > 0 && typeof args[args.length - 1] == "function") {
                callback = args.pop();
            }
            var err;
            var res;
            try {
                res = f.apply({}, args);
            }
            catch (e) {
                err = e;
            }
            if (callback) {
                callback(err, res);
            }
        }.bind(this);
    }
    MockMeteor.prototype.startup = function (f) {
        this.startupFkts.push(f);
    };
    MockMeteor.prototype.subscribe = function (name) {
    };
    MockMeteor.prototype.publish = function (name, f) {
        return undefined;
    };
    MockMeteor.prototype.runAllStartup = function () {
        this.startupFkts.forEach(function (f) {
            f();
        });
    };
    MockMeteor.prototype.wrapAsync = function (f) {
        return function () {
            var res;
            var err;
            var hasBeenCalled = false;
            f(function (e, r) {
                res = r;
                err = e;
                hasBeenCalled = true;
            });
            while (!hasBeenCalled) {
                require('deasync').sleep(50);
            }
            if (err)
                throw err;
            return res;
        };
    };
    MockMeteor.prototype.methods = function (dict) {
        _.extend(this.theMethods, dict);
    };
    return MockMeteor;
}());
exports.MockMeteor = MockMeteor;
function resetDatabases() {
    MockCollection.data = {};
}
exports.resetDatabases = resetDatabases;
function init() {
    exports.mockMongo = new MockMongo();
    exports.mockMeteor = new MockMeteor();
    omm.config({
        Meteor: exports.mockMeteor,
        Mongo: exports.mockMongo
    });
}
exports.init = init;
//# sourceMappingURL=Mocks.js.map